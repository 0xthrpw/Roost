/*
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%, .***.*@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&/. .,*****, *@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*...*********,,,&@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&%.////**********,..&@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&/,..//(((((/......../.,%@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&/..(((((#%##((/......../(.,&@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&((/(#####%%(((((......../@@(.,%@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@%,///##%%&&%#(###(******(@%(/..//&@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@&@@@&.,(((#%%&&&%##%&#(##.///#(((//((#/%@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@&. (@&*.,###%&&&%%#%&&/.%%&%%(/(////(((((/@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@&*,,.%&(.,&&&&&%%#((%@#*%thrpw%%###(//((((*&@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@&&(*..*%#,/@&%%%%(/./(%(&%&&&&&&&%%##///(((./@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@&,*%%(. ,#%,/%(/#%((///%(%%#%&&&&&&&%##((((((*.#@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@&(//((##(./#.(#/.(#////%%/((((#%&&&&&&&%####((,*#@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@&**(/(###%(/#//////////#&#***,,/#&&&&&&&&%##((/.,(@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@#./(((%%%%#(#*.////./*(#&(**,.../%&&&&&&&%#(((///%@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@&,.//%&@&%&///.////...,#%*.....//#@&@@&&&&&%%##*,&@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@/.,*(*#&&@%#(//////.. *&*,./...,*(%&&&&&&&&%%/.(@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@%,,./#*(&@&(((////*. .##,/.**../(#%%&&&%%%&#,,&@@@@@@@@@##@@@@@@@
@@@@@@@@@@@@@@@@%*,,/(./@&(/////(*  /&/.*****./(#&&%&&%(,/&@@@@@@%(##%@@@@@@@@@@
@@@@@@@@@@@@@@@@@&*..*#/.#%#/////* .##.*****./(#&##%%/,(@@@@&#(**(%@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@( /(#***(#////,.,%*.,****./%#(##* /@@&%/./,/%&@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@&@@@%*#*(/,.////.. /#.,******((((*.,&#*.*(,,#&@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@*,&@@&/#(./..///...%(,/.*****.//. ,, *%%,/%@@@@@%%@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@%#,/@@&#*#.////.,.,#/.********. ../#&%*#%&@@%((,../@@@@@@@@@@@@@
@@@@@@@@@@@@@%/(###*.#@&(./(///,. /%*,*,*,**,..,(#&(*(%%%//%%,(%/,@@@@@@@@@@@@@@
@@@@@@@@@@@@@%,/%####(,(#/..///,.,&#..*,,,,*,,./%/.//,.,%@&&&%#(,#@@@@@@@@@@@@@@
@@@@@@@@@@@@@&(/.*#%&&%#*,/.*,,,.*&/.,/,.. .*,..//,,*(&&%%&%#(/.#@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@/(##*,/#%&&#//.,,,,#%,.**,. .,,***.//#&&&&&&&#/(&@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@%&##%%%#**(#%%(*,. .&( .,.....,,,./#%&&&&&&&#//%@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@..(%%%%%%/.,./.,,.,&, ...,,,,/(((((%&&&&%#* (%((,%@@@@@@@@@@@@@@@@
@@@@@@@@@@@&#&@#*.,(#%%%#*..,.  /%   .,,,,,./(((#%#((*. ...,#/%@@@@@@@@@@@@@@@@@
@@@@@@@@@@@##, *(#(***((##/,    ((  .,,,,,,*./((*... ,/......(@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@#.  ,*, ,.///(///.. .%(  .,,,*,,**,,..,***,,....%@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@(.,.,,.   ..,,.//., .%/  ..,***....,././///.,/%,*&@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@/.,,//,..**  .,,,..*&/ .,,,,,,...////(//((/.  /@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@&(/./#///((*.       *%* ..,,,,,.,./////.*,... (@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@%,.,(#%#((#(.    ../%/ ..,,,...,*******,,.. (@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@&..,#%#%%#(/..   ,/#, ..,,...,,,,*****,,,/%@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@/. .,(%#%%(,    ,((. ........,,,.///..*,(@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@...   ,.(/./,   .((. ,......,,./((/...,&@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@#./,,.  .,//.*  .((..,.....,.////,. .#@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@#.,(/.*,. ./(,  .(#..*,...,****,,..,%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@%*.,((/(/,*...  /#.,,..,,,*(*,...(@@@@@&#@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@&(*./#(#%((*,,./%, . ....,...,#@@@@@&%(#@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@&&@@@@@#,/#%##%%%/,,/&/  ....., ,#@@@@@&&%(,#@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@#,/%&%@@&/.(%%%%%%%//&( ... ../@@@@@&/(%%/.%@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@#/&#%##&&%//&%%%##(,##.....,%@&&%///%%%#(/,(@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@&./&&#(((#%(#%%%%(,*%..../##**#&@&&%((#(/(&@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@%*,(&@#%&#&%&&%#**,#..,//(#&&&&@@&(#%%%#/&@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@&&#/.%&&&@&&&&%%//,((.,/((##&&@%%&&&%(*#@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@&&%%%%&&@@@&&@&&&%%#//(%,,*(#%%&&&&&&&%/#@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@&&&@@@@@@@&&&&&%#/,,%////(%&&&&&&&(%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@#/.(&&&&%&&&&@@&&&&&&&&%##*.%//(/(%%##%&%#%##((#%&@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@&%%%%%&&&&&&&&&@&&%%%%#*.#//##%&@&&@@@@@&&&&&&&@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@&(###%%&&@@&&&@@&&%%%(, /(./#%&&%(/(%%%&&@@&%##(&@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@&&%%%%%%&&&&&@&@&%%#(..#//#&&&&@&&%%&&&%%&@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@&&@@@&@&&&@&@@@@&%#(#,*%(##%&&@@@@@&&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@&#&@&&&&&&&%%(#(/&#%%%&&&&&&%&@&%&@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@%%&&%%%%#%%&/.&&#%&&%%&%#&&%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@&&&##&&@%&#%&#./&#%##&@@@@@@@&&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@%&%%(#%&%**%#%#%@@@@@@@@@@@&@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@&&/&&@@%/&%&&&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@%&@@@@@%%&(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@%@@@@@@@#&%&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@&@@@@@@@@%@%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@&@@@@@@@@@@%&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&&%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&&&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&&%&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&%#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@(#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

7.2
In the East there is a shark which is larger than all other fish.
It changes into a bird whose wings are like clouds filling the sky.
When this bird moves across the land, it brings a message from Corporate Headquarters.
This message it drops into the midst of the programmers, like a seagull making its mark upon the beach.
Then the bird mounts on the wind and, with the blue sky at its back, returns home.
The novice programmer stares in wonder at the bird, for he understands it not.
The average programmer dreads the coming of the bird, for he fears its message.
The Master Programmer continues to work at his terminal, unaware that the bird has come and gone.

*/

pragma solidity ^0.6.6;

abstract contract Context {
    function _msgSender() internal virtual view returns (address payable) {
        return msg.sender;
    }

    function _msgData() internal virtual view returns (bytes memory) {
        this;
        return msg.data;
    }
}

interface IERC20 {

    function totalSupply() external view returns (uint256);

    function balanceOf(address account) external view returns (uint256);

    function transfer(address recipient, uint256 amount)
        external
        returns (bool);

    function allowance(address owner, address spender)
        external
        view
        returns (uint256);

    function approve(address spender, uint256 amount) external returns (bool);

    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    function mint(address _to, uint256 _amount) external;

    event Transfer(address indexed from, address indexed to, uint256 value);

    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );
}

library SafeMath {

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    function sub(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    function div(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        uint256 c = a / b;
        return c;
    }

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    function mod(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}

interface SiloControlMigrator {
    function migrate(IERC20 token) external returns (IERC20);
}

library Address {

    function isContract(address account) internal view returns (bool) {

        uint256 size;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            size := extcodesize(account)
        }
        return size > 0;
    }

    function sendValue(address payable recipient, uint256 amount) internal {
        require(
            address(this).balance >= amount,
            "Address: insufficient balance"
        );

        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value
        (bool success, ) = recipient.call{value: amount}("");
        require(
            success,
            "Address: unable to send value, recipient may have reverted"
        );
    }

    function functionCall(address target, bytes memory data)
        internal
        returns (bytes memory)
    {
        return functionCall(target, data, "Address: low-level call failed");
    }

    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return _functionCallWithValue(target, data, 0, errorMessage);
    }

    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value
    ) internal returns (bytes memory) {
        return
            functionCallWithValue(
                target,
                data,
                value,
                "Address: low-level call with value failed"
            );
    }

    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(
            address(this).balance >= value,
            "Address: insufficient balance for call"
        );
        return _functionCallWithValue(target, data, value, errorMessage);
    }

    function _functionCallWithValue(
        address target,
        bytes memory data,
        uint256 weiValue,
        string memory errorMessage
    ) private returns (bytes memory) {
        require(isContract(target), "Address: call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = target.call{value: weiValue}(
            data
        );
        if (success) {
            return returndata;
        } else {
            if (returndata.length > 0) {
                // solhint-disable-next-line no-inline-assembly
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}

library SafeERC20 {
    using SafeMath for uint256;
    using Address for address;

    function safeTransfer(
        IERC20 token,
        address to,
        uint256 value
    ) internal {
        _callOptionalReturn(
            token,
            abi.encodeWithSelector(token.transfer.selector, to, value)
        );
    }

    function safeTransferFrom(
        IERC20 token,
        address from,
        address to,
        uint256 value
    ) internal {
        _callOptionalReturn(
            token,
            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)
        );
    }

    function safeApprove(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        require(
            (value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        _callOptionalReturn(
            token,
            abi.encodeWithSelector(token.approve.selector, spender, value)
        );
    }

    function safeIncreaseAllowance(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        uint256 newAllowance = token.allowance(address(this), spender).add(
            value
        );
        _callOptionalReturn(
            token,
            abi.encodeWithSelector(
                token.approve.selector,
                spender,
                newAllowance
            )
        );
    }

    function safeDecreaseAllowance(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        uint256 newAllowance = token.allowance(address(this), spender).sub(
            value,
            "SafeERC20: decreased allowance below zero"
        );
        _callOptionalReturn(
            token,
            abi.encodeWithSelector(
                token.approve.selector,
                spender,
                newAllowance
            )
        );
    }


    function _callOptionalReturn(IERC20 token, bytes memory data) private {
        bytes memory returndata = address(token).functionCall(
            data,
            "SafeERC20: low-level call failed"
        );
        if (returndata.length > 0) {
            // solhint-disable-next-line max-line-length
            require(
                abi.decode(returndata, (bool)),
                "SafeERC20: ERC20 operation did not succeed"
            );
        }
    }
}

contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(
        address indexed previousOwner,
        address indexed newOwner
    );

    constructor() internal {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    function owner() public view returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(_owner == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(
            newOwner != address(0),
            "Ownable: new owner is the zero address"
        );
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
/*
contract TokenRecover is Ownable {
    function recoverERC20(address tokenAddress, uint256 tokenAmount) public onlyOwner {
        IERC20(tokenAddress).transfer(owner(), tokenAmount);
    }
}
*/
interface IERC20Skeptical is IERC20 {
  function pushTarlist (address _tarlistedAddress) external;

  function unTarlist (address _tarlistedAddress) external;

  function isTarlisted (address _queryAddress) external view returns (bool);
}

interface IERC721 {
  function mintCard(address _to, uint256 _tokenId, address _proposedContract);
}

contract VoteControl is Ownable {
  using SafeMath for uint256;
  using SafeERC20 for IERC20Skeptical;

  //tokens
  IERC20Skeptical public featherToken;
  IERC721 public tarToken;  ####
  IERC721 public avianToken;

  address public featherFactory

  //counters
  uint256 public roundCounter;
  uint256 public propCounter;
  uint256 public rewardBalance;

  //configurable
  uint256 public propLimitPerRound;
  uint256 public minVotingWindowLength;
  uint256 public minFeatherForProposal;

  //switches
  bool public acceptingProposals;
  bool public acceptingVotes;

  struct VotingPool {
    address proposedContract;
    uint256 voteTally;
    uint256 rewardTally;
    uint256 multiplier; //weight ??
    uint256 rewardPerVote;
  }

  struct ProposalResult {
    address proposedContract;
    address proposer;
    uint256 rank;
    uint256 result;
    uint256 tally;
    uint256 endingBlock;  //this is for round, not proposal
  }

  struct RoundResult {
    address tarredContract;
    address proposer;
    uint256 totalVotes;
    uint256 totalRewardDistributed;
    uint256 blockStart;
    uint256 blockEnd;
  }
  //ROUND CENTRIC
  //list of contracts per round
  //contractsInRound[round] = (address => state)
  mapping(uint256 => mapping(address => bool)) public contractsInRound;

  mapping(uint256 => RoundResult) public roundResult;
  mapping(uint256 => address) public tarlisted;
  //ROUND / PROPOSAL CENTRIC
  //votingPool[round][proposalId] = votingPool(address(contract), voteTally)
  mapping(uint256 => mapping(uint256 => VotingPool)) public votingPool;

  //USER CENTRIC
  //record of user voting history
  //votingRecord[address][round] = (proposalID => amount)
  mapping(address => mapping(uint256 => mapping(uint256 => uint256))) public votingRecord;

  //USER REWARD STORAGE
  mapping(address => uint256) public featherTokenclaimableBalance; //uncompensatedVotes



  event contractProposalCommitted(uint256 indexed round, uint256 proposalId, address indexed user, address indexed contract);
  event proposalWindowOpened(uint256 indexed round);
  event proposalWindowClosed(uint256 indexed round);
  event votingWindowOpened(uint256 indexed round);
  event votingWindowClosed(uint256 indexed round);

  constructor(
    IERC20Skeptical _featherToken,
    IERC721 _avianToken,
    IERC721 _tarToken,
    address _featherFactory,
    uint256 _startBlock
  ) public {
      featherToken = _featherToken;
      avianToken = _avianToken;
      tarToken = _tarToken;
      featherFactory = _featherFactory;

    //  rooster = _rooster;
    //  rewardPerBlock = 1000 ether; //181834391801075000;
    //  startBlock = _startBlock;
      //lastHalveBlock = _startBlock;

      //initialize claimable pool
      rewardBalance = 0;
      acceptingVotes = false;
      acceptingProposals = true;
      propLimit = 10;
      minVotingWindowLength = 10000;
      minFeatherForProposal = 10 ether;
  }

  function depositReward(uint256 _amount) external {
      require(address(msg.sender) == featherFactory, "ONLY FEATHER FACTORY")

      rewardBalance = rewardBalance.add(_amount);
  }

  function vote(uint256 _proposalId, uint256 _amount) public {
      //require proposal is open for voting
      require(acceptingVotes, "VOTING DISABLED");

      //voters can't be a contract
      require(!isContract(address(msg.sender)), "VOTERS CAN NOT BE CONTRACTS");

      //require user hasn't voted this round
      require(!votingRecord[address(msg.sender)][roundCounter], "USER HAS ALREADY SUBMITTED PROPOSAL FOR THIS ROUND");

      //setup user record
      //update user balance
      votingRecord[address(msg.sender)][roundCounter][propCounter] = _amount;

      //update voting pool balance
      VotingPool storage vp = votingPool[roundCounter][propCounter];
      vp.voteTally = vp.voteTally.add(_amount);

      //
      checkVotingWindowTrigger();
  }

  function claim(uint256 _round, uint256 _proposalId) public {
      uint256 claimableRounds = roundCounter.sub(1);

      //number of proposals in round
      uint256 length = contractsInRound[roundCounter].length;

      //set total reward owed
      uint256 totalVotes = 0;

      //loop the voting pools and add up total vote tally
      for (uint256 rounds = 0; rounds < claimableRounds; ++rounds) {
        //get final round vote tally
        //get users contribution for round
        //get vote result for round
        //calculate owed reward
        //set value owed aside
        //reset user balances
        //add to claimable balance
      }


      //require user has outstanding balance

      //set pendingReward = outstanding balance

      //setup user data

      //clear user balance to zero

      //send pendingReward

      //
      checkVotingWindowTrigger();
  }


  function setProposal(address _contractAddress) public {
      //proposer can't be a contract
      require(!isContract(address(msg.sender)), "CONTRACTS CAN NOT BE PROPOSERS");

      //require proposals are open
      require(acceptingProposals, "PROPOSAL SUBMISSIONS DISABLED");

      //require proposal doesn't already exist in round
      require(!contractsInRound[roundCounter][_contractAddress], "PROPOSAL ALREADY SUBMITTED FOR THIS ROUND");

      //require proposed contract hasn't already been tarlisted
      require(!featherToken.isTarlisted(_proppedContract), "CONTRACT IS ALREADY BLACKLISTED");

      //make sure proposer has nonzero FTHR balance
      require(featherToken.balanceOf(address(msg.sender)) > minFeatherForProposal, "INSUFFICIENT FTHR BALANCE");


      //add pool, if prop limit reached then close prop window and start voting
      if(propcounter < propLimitPerRound){
        _addVotingPool(_contractAddress);
      }else{
        _closeProposalWindow();
      }
  }

  function _addVotingPool(address _proppedContract) internal {
      //require proposal count hasn't been maxed
      require(propCounter < propLimitPerRound, "PROPOSAL LIMIT REACHED");

      //add pool to round
      VotingPool storage vp = votingPool[roundCounter][propCounter];
      vp.proposedContract = _proppedContract;
      vp.voteTally = 0;


      //add proposed contract to contractsInRound
      contractsInRound[roundCounter][propCounter] = _proppedContract;

      propCounter = propCounter.add(1);


  }

  function setPropLimit(uint256 _propLimit) public onlyOwner {
      propLimit = _propLimit;
  }

  function setVotingWindowLength(uint256 _windowLength) public onlyOwner {
      minVotingWindowLength = _windowLength;
  }

  function setMinFeatherForProposal(uint256 _minFeatherForProposal) public onlyOwner {
      minFeatherForProposal = _minFeatherForProposal;
  }
/*
  function setRooster(address _rooster) public {
      //make sure sender is rooster
      require(msg.sender == rooster, "ONLY CURRENT ROOSTER CAN SET NEW ROOSTER");
      rooster = _rooster;
  }
*/

  /*  */

  function _calculateRewardRatio() internal {
    //number of proposals in round
    uint256 length = contractsInRound[roundCounter].length;

    //set vote counter at 0
    uint256 totalVotes = 0;

    //loop the voting pools and add up total vote tally
    for (uint256 prop = 0; prop < length; ++prop) {
      VotingPool storage vp = votingPool[roundCounter][prop];
      totalVotes = totalVotes.add(vp.voteTally);
    }

    //reward ratio is feather balance...
    //uint256 featherBalance = _featherToken.balanceOf(address(this));

    //minus feather deposited from votes...
    //uint256 rewardBalance = featherBalance.sub(totalVotes);

    //divided by total votes
    uint256 rewardRatio = rewardBalance.div(totalVotes);
  }

  function _openProposalWindow() internal {
      //make sure proposal window is closed
      require(!acceptingProposals, "PROPOSAL WINDOW ALREADY OPEN");

      //make sure voting isn't open
      require(!acceptingVotes, "VOTING WINDOW IS STILL OPEN");

      acceptingProposals = true;
  }

  function _closeProposalWindow() internal {
      //make sure proposal window is open
      require(acceptingProposals, "PROPOSAL WINDOW IS NOT OPEN");

      acceptingProposals = false;

      _openVotingWindow();
  }

  function _openVotingWindow() internal {
      //make sure proposal window is closed
      require(!acceptingProposals, "PROPOSAL WINDOW STILL OPEN");

      //make sure voting isn't already open
      require(!acceptingVotes, "VOTING WINDOW IS ALREADY OPEN");

      //open voting window
      acceptingVotes = true;
  }

  function _closeVotingWindow() internal {

      //make sure voting is open
      require(acceptingVotes, "VOTING WINDOW IS NOT OPEN");

      //require block limit has passed

      //require

      //close voting window
      acceptingVotes = false;

      //expensive?
      _tallyVotes();

      //sweep all balances to clamable pool
    //  _setClaimableBalances();

  }

  /**
      SHOULD THIS FUNCTION BE PUBLIC?
      MAYBE KEEP INTERNAL AND ONLY CALL ON VOTES
  */

  function checkVotingWindowTrigger() public {
      //make sure voting window is open
      require(acceptingVotes, "VOTING WINDOW IS ALREADY CLOSED");
      //make sure minimum voting window time is satisfied
      require(votingPeriodStart + minVotingWindowLength > block.number, "MINIMUM VOTING WINDOW THRESHOLD NOT BROKEN");

      //this isn't true random, but should be good enough
      bytes32 pseudoRando = keccak256(block.blockhash);

      return uint256(pseudoRando) % 2 == 0;
  }

  function _tallyVotes() internal {
      //SETUP CURRENT ROUND STATE
      // SET VOTEMAX = 0;
      //FOR I < VOTING POOL LENGTH {
      //  IF VOTINGPOOL.AMOUNT > VOTEMAX: VOTEMAX = VOTINGPOOL.AMOUNT, WINNER = VOTINGPOOL.ID;
      //
      //
      rewardBalance = 0;
    }
  }
/*
  function _setClaimableBalances() internal {

  }
*/
}