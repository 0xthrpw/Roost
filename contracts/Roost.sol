/*
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%, .***.*@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&/. .,*****, *@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*...*********,,,&@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&%.////**********,..&@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&/,..//(((((/......../.,%@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&/..(((((#%##((/......../(.,&@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&((/(#####%%(((((......../@@(.,%@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@%,///##%%&&%#(###(******(@%(/..//&@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@&@@@&.,(((#%%&&&%##%&#(##.///#(((//((#/%@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@&. (@&*.,###%&&&%%#%&&/.%%&%%(/(////(((((/@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@&*,,.%&(.,&&&&&%%#((%@#*%thrpw%%###(//((((*&@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@&&(*..*%#,/@&%%%%(/./(%(&%&&&&&&&%%##///(((./@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@&,*%%(. ,#%,/%(/#%((///%(%%#%&&&&&&&%##((((((*.#@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@&(//((##(./#.(#/.(#////%%/((((#%&&&&&&&%####((,*#@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@&**(/(###%(/#//////////#&#***,,/#&&&&&&&&%##((/.,(@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@#./(((%%%%#(#*.////./*(#&(**,.../%&&&&&&&%#(((///%@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@&,.//%&@&%&///.////...,#%*.....//#@&@@&&&&&%%##*,&@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@/.,*(*#&&@%#(//////.. *&*,./...,*(%&&&&&&&&%%/.(@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@%,,./#*(&@&(((////*. .##,/.**../(#%%&&&%%%&#,,&@@@@@@@@@##@@@@@@@
@@@@@@@@@@@@@@@@%*,,/(./@&(/////(*  /&/.*****./(#&&%&&%(,/&@@@@@@%(##%@@@@@@@@@@
@@@@@@@@@@@@@@@@@&*..*#/.#%#/////* .##.*****./(#&##%%/,(@@@@&#(**(%@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@( /(#***(#////,.,%*.,****./%#(##* /@@&%/./,/%&@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@&@@@%*#*(/,.////.. /#.,******((((*.,&#*.*(,,#&@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@*,&@@&/#(./..///...%(,/.*****.//. ,, *%%,/%@@@@@%%@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@%#,/@@&#*#.////.,.,#/.********. ../#&%*#%&@@%((,../@@@@@@@@@@@@@
@@@@@@@@@@@@@%/(###*.#@&(./(///,. /%*,*,*,**,..,(#&(*(%%%//%%,(%/,@@@@@@@@@@@@@@
@@@@@@@@@@@@@%,/%####(,(#/..///,.,&#..*,,,,*,,./%/.//,.,%@&&&%#(,#@@@@@@@@@@@@@@
@@@@@@@@@@@@@&(/.*#%&&%#*,/.*,,,.*&/.,/,.. .*,..//,,*(&&%%&%#(/.#@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@/(##*,/#%&&#//.,,,,#%,.**,. .,,***.//#&&&&&&&#/(&@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@%&##%%%#**(#%%(*,. .&( .,.....,,,./#%&&&&&&&#//%@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@..(%%%%%%/.,./.,,.,&, ...,,,,/(((((%&&&&%#* (%((,%@@@@@@@@@@@@@@@@
@@@@@@@@@@@&#&@#*.,(#%%%#*..,.  /%   .,,,,,./(((#%#((*. ...,#/%@@@@@@@@@@@@@@@@@
@@@@@@@@@@@##, *(#(***((##/,    ((  .,,,,,,*./((*... ,/......(@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@#.  ,*, ,.///(///.. .%(  .,,,*,,**,,..,***,,....%@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@(.,.,,.   ..,,.//., .%/  ..,***....,././///.,/%,*&@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@/.,,//,..**  .,,,..*&/ .,,,,,,...////(//((/.  /@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@&(/./#///((*.       *%* ..,,,,,.,./////.*,... (@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@%,.,(#%#((#(.    ../%/ ..,,,...,*******,,.. (@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@&..,#%#%%#(/..   ,/#, ..,,...,,,,*****,,,/%@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@/. .,(%#%%(,    ,((. ........,,,.///..*,(@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@...   ,.(/./,   .((. ,......,,./((/...,&@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@#./,,.  .,//.*  .((..,.....,.////,. .#@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@#.,(/.*,. ./(,  .(#..*,...,****,,..,%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@%*.,((/(/,*...  /#.,,..,,,*(*,...(@@@@@&#@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@&(*./#(#%((*,,./%, . ....,...,#@@@@@&%(#@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@&&@@@@@#,/#%##%%%/,,/&/  ....., ,#@@@@@&&%(,#@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@#,/%&%@@&/.(%%%%%%%//&( ... ../@@@@@&/(%%/.%@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@#/&#%##&&%//&%%%##(,##.....,%@&&%///%%%#(/,(@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@&./&&#(((#%(#%%%%(,*%..../##**#&@&&%((#(/(&@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@%*,(&@#%&#&%&&%#**,#..,//(#&&&&@@&(#%%%#/&@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@&&#/.%&&&@&&&&%%//,((.,/((##&&@%%&&&%(*#@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@&&%%%%&&@@@&&@&&&%%#//(%,,*(#%%&&&&&&&%/#@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@&&&@@@@@@@&&&&&%#/,,%////(%&&&&&&&(%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@#/.(&&&&%&&&&@@&&&&&&&&%##*.%//(/(%%##%&%#%##((#%&@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@&%%%%%&&&&&&&&&@&&%%%%#*.#//##%&@&&@@@@@&&&&&&&@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@&(###%%&&@@&&&@@&&%%%(, /(./#%&&%(/(%%%&&@@&%##(&@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@&&%%%%%%&&&&&@&@&%%#(..#//#&&&&@&&%%&&&%%&@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@&&@@@&@&&&@&@@@@&%#(#,*%(##%&&@@@@@&&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@&#&@&&&&&&&%%(#(/&#%%%&&&&&&%&@&%&@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@%%&&%%%%#%%&/.&&#%&&%%&%#&&%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@&&&##&&@%&#%&#./&#%##&@@@@@@@&&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@%&%%(#%&%**%#%#%@@@@@@@@@@@&@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@&&/&&@@%/&%&&&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@%&@@@@@%%&(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@%@@@@@@@#&%&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@&@@@@@@@@%@%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@&@@@@@@@@@@%&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&&%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&&&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&&%&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&%#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@(#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

7.2
In the East there is a shark which is larger than all other fish.
It changes into a bird whose wings are like clouds filling the sky.
When this bird moves across the land, it brings a message from Corporate Headquarters.
This message it drops into the midst of the programmers, like a seagull making its mark upon the beach.
Then the bird mounts on the wind and, with the blue sky at its back, returns home.
The novice programmer stares in wonder at the bird, for he understands it not.
The average programmer dreads the coming of the bird, for he fears its message.
The Master Programmer continues to work at his terminal, unaware that the bird has come and gone.

*/

pragma solidity ^0.6.6;

abstract contract Context {
    function _msgSender() internal virtual view returns (address payable) {
        return msg.sender;
    }

    function _msgData() internal virtual view returns (bytes memory) {
        this;
        return msg.data;
    }
}

interface IERC20 {

    function totalSupply() external view returns (uint256);

    function balanceOf(address account) external view returns (uint256);

    function transfer(address recipient, uint256 amount)
        external
        returns (bool);

    function allowance(address owner, address spender)
        external
        view
        returns (uint256);

    function approve(address spender, uint256 amount) external returns (bool);

    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    function mint(address _to, uint256 _amount) external;

    event Transfer(address indexed from, address indexed to, uint256 value);

    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );
}

library SafeMath {

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    function sub(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    function div(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        uint256 c = a / b;
        return c;
    }

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    function mod(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}

library Address {

    function isContract(address account) internal view returns (bool) {

        uint256 size;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            size := extcodesize(account)
        }
        return size > 0;
    }

    function sendValue(address payable recipient, uint256 amount) internal {
        require(
            address(this).balance >= amount,
            "Address: insufficient balance"
        );

        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value
        (bool success, ) = recipient.call{value: amount}("");
        require(
            success,
            "Address: unable to send value, recipient may have reverted"
        );
    }

    function functionCall(address target, bytes memory data)
        internal
        returns (bytes memory)
    {
        return functionCall(target, data, "Address: low-level call failed");
    }

    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return _functionCallWithValue(target, data, 0, errorMessage);
    }

    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value
    ) internal returns (bytes memory) {
        return
            functionCallWithValue(
                target,
                data,
                value,
                "Address: low-level call with value failed"
            );
    }

    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(
            address(this).balance >= value,
            "Address: insufficient balance for call"
        );
        return _functionCallWithValue(target, data, value, errorMessage);
    }

    function _functionCallWithValue(
        address target,
        bytes memory data,
        uint256 weiValue,
        string memory errorMessage
    ) private returns (bytes memory) {
        require(isContract(target), "Address: call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = target.call{value: weiValue}(
            data
        );
        if (success) {
            return returndata;
        } else {
            if (returndata.length > 0) {
                // solhint-disable-next-line no-inline-assembly
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}

library SafeERC20 {
    using SafeMath for uint256;
    using Address for address;

    function safeTransfer(
        IERC20 token,
        address to,
        uint256 value
    ) internal {
        _callOptionalReturn(
            token,
            abi.encodeWithSelector(token.transfer.selector, to, value)
        );
    }

    function safeTransferFrom(
        IERC20 token,
        address from,
        address to,
        uint256 value
    ) internal {
        _callOptionalReturn(
            token,
            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)
        );
    }

    function safeApprove(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        require(
            (value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        _callOptionalReturn(
            token,
            abi.encodeWithSelector(token.approve.selector, spender, value)
        );
    }

    function safeIncreaseAllowance(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        uint256 newAllowance = token.allowance(address(this), spender).add(
            value
        );
        _callOptionalReturn(
            token,
            abi.encodeWithSelector(
                token.approve.selector,
                spender,
                newAllowance
            )
        );
    }

    function safeDecreaseAllowance(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        uint256 newAllowance = token.allowance(address(this), spender).sub(
            value,
            "SafeERC20: decreased allowance below zero"
        );
        _callOptionalReturn(
            token,
            abi.encodeWithSelector(
                token.approve.selector,
                spender,
                newAllowance
            )
        );
    }


    function _callOptionalReturn(IERC20 token, bytes memory data) private {
        bytes memory returndata = address(token).functionCall(
            data,
            "SafeERC20: low-level call failed"
        );
        if (returndata.length > 0) {
            // solhint-disable-next-line max-line-length
            require(
                abi.decode(returndata, (bool)),
                "SafeERC20: ERC20 operation did not succeed"
            );
        }
    }
}

contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(
        address indexed previousOwner,
        address indexed newOwner
    );

    constructor() internal {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    function owner() public view returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(_owner == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(
            newOwner != address(0),
            "Ownable: new owner is the zero address"
        );
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

interface IERC20Skeptical is IERC20 {
  function pushTarlist (address _tarlistedAddress) external;

  function unTarlist (address _tarlistedAddress) external;

  function isTarlisted (address _queryAddress) external view returns (bool);
}

interface IERC721 {
  function mintCard(address _to, uint256 _tokenId, address _proposedContract);
}

contract Roost is Ownable {
  using SafeMath for uint256;
  using SafeERC20 for IERC20Skeptical;

  // tokens
  IERC20Skeptical public featherToken;
  IERC721 public tarToken;
  IERC721 public avianToken;
  address public featherFactory;

  // counters
  uint256 public roundCounter;
  uint256 public propCounter;

  // switches
  bool public acceptingProposals;
  bool public acceptingVotes;


  struct Ballot {
    uint256 candidate;    //proposalId
    uint256 voteAmount;
    uint256 blockNumber;  //vote blockstamp
  }

  // user address => round_id => ballot struct
  mapping(address => mapping(uint256 => Ballot)) public votingRecord;

  struct Proposal {
    address target;
    address proposer;
    uint256 voteTally;
    uint256 lastVoteBlock;
    uint256 voteBlocks;
  }
  // round_id => proposal_id => proposal struct
  mapping(uint256 => mapping(uint256 => Proposal)) public proposal;

  struct Round {
    uint256 totalVotes;
    uint256 totalVoteBlocks;

    uint256 startBlock;
    uint256 lastCalcBlock;
    uint256 endBlock;

    uint256 distributedReward;
    uint256 distributedBonus;
  }
  // round_id => round struct
  mapping(uint256 => Round) public round;

  // round_id => target => bool
  mapping(uint256 => mapping(address => bool)) public contractsInRound;

  // round_id => proposer address
  mapping(uint256 => address) public winningProposers;

  // round_id => proposal target
  mapping(uint256 => address) public winningContracts;

  // user address => round_id => outstanding reward base
  mapping(address => mapping(uint256 => uint256)) public uncompensatedVotes;

  //
  mapping(uint256 => uint256) public roundReward;
  mapping(uint256 => uint256) public roundBonus;

  constructor(
    IERC20Skeptical _featherToken,
    IERC721 _avianToken,
    IERC721 _tarToken,
    address _featherFactory,
    uint256 _startBlock
  ) public {
    featherToken = _featherToken;
    avianToken = _avianToken;
    tarToken = _tarToken;
    featherFactory = _featherFactory;

    startBlock = _startBlock;
    rewardBalance = 0;
    acceptingVotes = false;
    acceptingProposals = true;
    propLimit = 10;
    minVotingWindowLength = 10000;
    minFeatherForProposal = 10 * 1e18;
  }

  /**
    this function is called by the featherFactory to deposit voting rewards
  **/
  function depositReward(uint256 _amount) external {
      //can only be called by the feather factory
      require(address(msg.sender) == featherFactory, "ONLY FEATHER FACTORY");
      //caluclate 30% for bonus
      uint256 bonusReward = _amount.mul(30).div(100);
      //peel it off base reward
      uint256 baseReward = _amount.sub(bonusReward);
      //and assign to reward for round
      roundReward[roundCounter] = roundReward[roundCounter].add(baseReward);
      roundBonus[roundCounter] = roundBonus[roundCounter].add(bonusReward);
      //rewardBalance = rewardBalance.add(_amount);
  }

  /**
  STATE
  **/
  function _openProposalWindow() internal {
      //make sure proposal window is closed
      require(!acceptingProposals, "PROPOSAL WINDOW ALREADY OPEN");

      //make sure voting isn't open
      require(!acceptingVotes, "VOTING WINDOW IS STILL OPEN");

      acceptingProposals = true;
  }

  function _closeProposalWindow() internal {
      //make sure proposal window is open
      require(acceptingProposals, "PROPOSAL WINDOW IS NOT OPEN");

      //make sure voting isn't open
      require(!acceptingVotes, "VOTING WINDOW IS OPEN");

      acceptingProposals = false;
  }

  function _openVotingWindow() internal {
      //make sure proposal window is closed
      require(!acceptingProposals, "PROPOSAL WINDOW STILL OPEN");

      //make sure voting isn't already open
      require(!acceptingVotes, "VOTING WINDOW IS ALREADY OPEN");

      //open voting window
      acceptingVotes = true;

      _initRound();
  }

  function _closeVotingWindow() internal {
      //make sure proposal window is closed
      require(!acceptingProposals, "PROPOSAL WINDOW IS OPEN");

      //make sure voting is open
      require(acceptingVotes, "VOTING WINDOW IS NOT OPEN");

      //require block limit has passed

      //close voting window
      acceptingVotes = false;

      _closeRound();

  }

  function _closeRound() internal {
      _updateRoundCalcs();

      address winningContract = "0x";
      uint256 totalVoteTally = 0;
      uint256 tallyHigh = 0;

      uint256 proposalsLength = proposal[roundCounter].length;

      for (uint256 propId = 0; propId < proposalsLength; ++propId) {
          Proposal storage prop = proposal[roundCounter][propId];
          totalVoteTally = totalVoteTally.add(prop.voteTally);

          if(prop.voteTally > tallyHigh){
              tallyHigh = prop.voteTally;
              winningContract = prop.proposedContract;
              winningProposer = prop.proposer;
          }
      }

      //record winner for round
      winningProposers[roundCounter] = winningProposer;

      Round storage roundMeta = round[roundCounter];
      roundMeta.endBlock = block.number;
      roundMeta.totalVotes = totalVoteTally;

      roundMeta.reward = rewardBalance;
      rewardBalance = 0;
      propCounter = 0;

      ++roundCounter;
  }

  function _updateRoundCalcs() internal {
      //update round meta
      Round storage roundMeta = round[roundCounter];

      //calculate voteBlocks
      uint256 voteBlocksPassed = block.number - roundMeta.lastCalcBlock;
      uint256 newVoteBlocks = roundMeta.totalVotes.mul(voteBlocksPassed);
      roundMeta.voteBlocks = roundMeta.voteBlocks.add(newVoteBlocks);

      roundMeta.lastCalcBlock = block.number;
  }

  function _updateProposalCalcs(uint256 _proposalId) internal {
      Proposal storage prop = proposal[roundCounter][_proposalId];

  }

  function _addVotingPool(address _proppedContract) internal {
      //require proposal count hasn't been maxed
      require(propCounter < propLimitPerRound, "PROPOSAL LIMIT REACHED");

      //add proposal to round
      Proposal storage prop = proposal[roundCounter][propCounter];
      prop.proposedContract = _proppedContract;
      prop.voteTally = 0;

      //add proposed contract to contractsInRound
      contractsInRound[roundCounter][_proppedContract] = true;
      proposersInRound[roundCounter][address(msg.sender)] = true;

      ++propCounter;
  }

  function _initRound() internal {
      //set round meta
      Round storage roundMeta = round[roundCounter];
      roundMeta.lastCalcBlock = block.number;
      roundMeta.startBlock = block.number;
      roundMeta.totalVotes = 0;
      roundMeta.distributedReward = 0;
      roundMeta.distributedBonus = 0;
      roundMeta.voteBlocks = 0;
  }

  function _checkVotingWindowTrigger() internal {
      //make sure voting window is open
      require(acceptingVotes, "VOTING WINDOW IS ALREADY CLOSED");
      //make sure minimum voting window time is satisfied
      Round storage roundMeta = round[roundCounter];
      require(roundMeta.startBlock + minVotingWindowLength > block.number, "MINIMUM VOTING WINDOW THRESHOLD NOT BROKEN");

      //this isn't true random, but should be good enough
      bytes32 pseudoRando = keccak256(block.blockhash, roundMeta.startBlock, roundMeta.proposer);

      uint256 window = minVotingWindowLength + block.number;
      if(uint256(pseudoRando) % window == 0){
        _closeVotingWindow();
        _openProposalWindow();
      }
  }

  /**
  CONFIG
  **/

  function setPropLimit(uint256 _propLimit) public onlyOwner {
      require(_propLimit > 1 && _propLimit < 15, "PROP LIMIT MUST BE BETWEEN 2 - 14");
      propLimit = _propLimit;
  }

  function setVotingWindowLength(uint256 _windowLength) public onlyOwner {
      require(_windowLength > 5000, "VOTING WINDOW MUST BE A LEAST 5000 BLOCKS");
      require(_windowLength < 100000, "VOTING WINDOW MUST BE LESS THAN 100000 BLOCKS");
      minVotingWindowLength = _windowLength;
  }

  function setMinFeatherForProposal(uint256 _minFeatherForProposal) public onlyOwner {
      require(_minFeatherForProposal > 1 && _minFeatherForProposal < 10000, "FTHR BALANCE FOR PROPOSAL MUST BE GREATER THAN 1 AND LESS THAN 10,000");
      minFeatherForProposal = _minFeatherForProposal;
  }

  /**
  PUB
  **/

  function setProposal(address _contractAddress) public {
      address proppedContract = address(_contractAddress);

      //require proposals are open
      require(acceptingProposals, "PROPOSAL SUBMISSIONS DISABLED");

      //proposer can't be a contract
      require(!isContract(address(msg.sender)), "CONTRACTS CAN NOT BE PROPOSERS");

      //require proposal doesn't already exist in round
      require(!contractsInRound[roundCounter][proppedContract], "PROPOSAL ALREADY SUBMITTED FOR THIS ROUND");

      //require proposer doesn't already exist in round
      require(!proposersInRound[roundCounter][address(msg.sender)], "PROPOSER HAS ALREADY SUBMITTED FOR THIS ROUND");

      //make sure user isn't winner from last round
      require(winningProposers[roundCounter - 1] != address(msg.sender), "PROPOSER CANT BE WINNING PROPOSER FROM LAST ROUND");

      //require proposed contract hasn't already been tarlisted
      require(!featherToken.isTarlisted(proppedContract), "CONTRACT IS ALREADY TARLISTED");

      //make sure proposer has nonzero FTHR balance
      require(featherToken.balanceOf(address(msg.sender)) > minFeatherForProposal, "INSUFFICIENT FTHR BALANCE");

      //add pool, if prop limit reached then close prop window and start voting
      if(propcounter < propLimitPerRound){
        _addVotingPool(proppedContract);
      }else{
        _closeProposalWindow();
        _openVotingWindow();
      }
  }


}
