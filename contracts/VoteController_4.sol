/*
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%, .***.*@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&/. .,*****, *@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*...*********,,,&@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&%.////**********,..&@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&/,..//(((((/......../.,%@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&/..(((((#%##((/......../(.,&@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&((/(#####%%(((((......../@@(.,%@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@%,///##%%&&%#(###(******(@%(/..//&@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@&@@@&.,(((#%%&&&%##%&#(##.///#(((//((#/%@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@&. (@&*.,###%&&&%%#%&&/.%%&%%(/(////(((((/@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@&*,,.%&(.,&&&&&%%#((%@#*%thrpw%%###(//((((*&@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@&&(*..*%#,/@&%%%%(/./(%(&%&&&&&&&%%##///(((./@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@&,*%%(. ,#%,/%(/#%((///%(%%#%&&&&&&&%##((((((*.#@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@&(//((##(./#.(#/.(#////%%/((((#%&&&&&&&%####((,*#@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@&**(/(###%(/#//////////#&#***,,/#&&&&&&&&%##((/.,(@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@#./(((%%%%#(#*.////./*(#&(**,.../%&&&&&&&%#(((///%@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@&,.//%&@&%&///.////...,#%*.....//#@&@@&&&&&%%##*,&@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@/.,*(*#&&@%#(//////.. *&*,./...,*(%&&&&&&&&%%/.(@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@%,,./#*(&@&(((////*. .##,/.**../(#%%&&&%%%&#,,&@@@@@@@@@##@@@@@@@
@@@@@@@@@@@@@@@@%*,,/(./@&(/////(*  /&/.*****./(#&&%&&%(,/&@@@@@@%(##%@@@@@@@@@@
@@@@@@@@@@@@@@@@@&*..*#/.#%#/////* .##.*****./(#&##%%/,(@@@@&#(**(%@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@( /(#***(#////,.,%*.,****./%#(##* /@@&%/./,/%&@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@&@@@%*#*(/,.////.. /#.,******((((*.,&#*.*(,,#&@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@*,&@@&/#(./..///...%(,/.*****.//. ,, *%%,/%@@@@@%%@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@%#,/@@&#*#.////.,.,#/.********. ../#&%*#%&@@%((,../@@@@@@@@@@@@@
@@@@@@@@@@@@@%/(###*.#@&(./(///,. /%*,*,*,**,..,(#&(*(%%%//%%,(%/,@@@@@@@@@@@@@@
@@@@@@@@@@@@@%,/%####(,(#/..///,.,&#..*,,,,*,,./%/.//,.,%@&&&%#(,#@@@@@@@@@@@@@@
@@@@@@@@@@@@@&(/.*#%&&%#*,/.*,,,.*&/.,/,.. .*,..//,,*(&&%%&%#(/.#@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@/(##*,/#%&&#//.,,,,#%,.**,. .,,***.//#&&&&&&&#/(&@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@%&##%%%#**(#%%(*,. .&( .,.....,,,./#%&&&&&&&#//%@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@..(%%%%%%/.,./.,,.,&, ...,,,,/(((((%&&&&%#* (%((,%@@@@@@@@@@@@@@@@
@@@@@@@@@@@&#&@#*.,(#%%%#*..,.  /%   .,,,,,./(((#%#((*. ...,#/%@@@@@@@@@@@@@@@@@
@@@@@@@@@@@##, *(#(***((##/,    ((  .,,,,,,*./((*... ,/......(@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@#.  ,*, ,.///(///.. .%(  .,,,*,,**,,..,***,,....%@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@(.,.,,.   ..,,.//., .%/  ..,***....,././///.,/%,*&@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@/.,,//,..**  .,,,..*&/ .,,,,,,...////(//((/.  /@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@&(/./#///((*.       *%* ..,,,,,.,./////.*,... (@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@%,.,(#%#((#(.    ../%/ ..,,,...,*******,,.. (@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@&..,#%#%%#(/..   ,/#, ..,,...,,,,*****,,,/%@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@/. .,(%#%%(,    ,((. ........,,,.///..*,(@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@...   ,.(/./,   .((. ,......,,./((/...,&@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@#./,,.  .,//.*  .((..,.....,.////,. .#@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@#.,(/.*,. ./(,  .(#..*,...,****,,..,%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@%*.,((/(/,*...  /#.,,..,,,*(*,...(@@@@@&#@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@&(*./#(#%((*,,./%, . ....,...,#@@@@@&%(#@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@&&@@@@@#,/#%##%%%/,,/&/  ....., ,#@@@@@&&%(,#@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@#,/%&%@@&/.(%%%%%%%//&( ... ../@@@@@&/(%%/.%@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@#/&#%##&&%//&%%%##(,##.....,%@&&%///%%%#(/,(@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@&./&&#(((#%(#%%%%(,*%..../##**#&@&&%((#(/(&@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@%*,(&@#%&#&%&&%#**,#..,//(#&&&&@@&(#%%%#/&@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@&&#/.%&&&@&&&&%%//,((.,/((##&&@%%&&&%(*#@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@&&%%%%&&@@@&&@&&&%%#//(%,,*(#%%&&&&&&&%/#@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@&&&@@@@@@@&&&&&%#/,,%////(%&&&&&&&(%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@#/.(&&&&%&&&&@@&&&&&&&&%##*.%//(/(%%##%&%#%##((#%&@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@&%%%%%&&&&&&&&&@&&%%%%#*.#//##%&@&&@@@@@&&&&&&&@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@&(###%%&&@@&&&@@&&%%%(, /(./#%&&%(/(%%%&&@@&%##(&@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@&&%%%%%%&&&&&@&@&%%#(..#//#&&&&@&&%%&&&%%&@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@&&@@@&@&&&@&@@@@&%#(#,*%(##%&&@@@@@&&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@&#&@&&&&&&&%%(#(/&#%%%&&&&&&%&@&%&@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@%%&&%%%%#%%&/.&&#%&&%%&%#&&%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@&&&##&&@%&#%&#./&#%##&@@@@@@@&&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@%&%%(#%&%**%#%#%@@@@@@@@@@@&@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@&&/&&@@%/&%&&&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@%&@@@@@%%&(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@%@@@@@@@#&%&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@&@@@@@@@@%@%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@&@@@@@@@@@@%&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&&%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&&&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&&%&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&%#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@(#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

7.2
In the East there is a shark which is larger than all other fish.
It changes into a bird whose wings are like clouds filling the sky.
When this bird moves across the land, it brings a message from Corporate Headquarters.
This message it drops into the midst of the programmers, like a seagull making its mark upon the beach.
Then the bird mounts on the wind and, with the blue sky at its back, returns home.
The novice programmer stares in wonder at the bird, for he understands it not.
The average programmer dreads the coming of the bird, for he fears its message.
The Master Programmer continues to work at his terminal, unaware that the bird has come and gone.

*/

pragma solidity ^0.6.6;

abstract contract Context {
    function _msgSender() internal virtual view returns (address payable) {
        return msg.sender;
    }

    function _msgData() internal virtual view returns (bytes memory) {
        this;
        return msg.data;
    }
}

interface IERC20 {

    function totalSupply() external view returns (uint256);

    function balanceOf(address account) external view returns (uint256);

    function transfer(address recipient, uint256 amount)
        external
        returns (bool);

    function allowance(address owner, address spender)
        external
        view
        returns (uint256);

    function approve(address spender, uint256 amount) external returns (bool);

    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    function mint(address _to, uint256 _amount) external;

    event Transfer(address indexed from, address indexed to, uint256 value);

    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );
}

library SafeMath {

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    function sub(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    function div(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        uint256 c = a / b;
        return c;
    }

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    function mod(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}

library Address {

    function isContract(address account) internal view returns (bool) {

        uint256 size;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            size := extcodesize(account)
        }
        return size > 0;
    }

    function sendValue(address payable recipient, uint256 amount) internal {
        require(
            address(this).balance >= amount,
            "Address: insufficient balance"
        );

        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value
        (bool success, ) = recipient.call{value: amount}("");
        require(
            success,
            "Address: unable to send value, recipient may have reverted"
        );
    }

    function functionCall(address target, bytes memory data)
        internal
        returns (bytes memory)
    {
        return functionCall(target, data, "Address: low-level call failed");
    }

    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return _functionCallWithValue(target, data, 0, errorMessage);
    }

    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value
    ) internal returns (bytes memory) {
        return
            functionCallWithValue(
                target,
                data,
                value,
                "Address: low-level call with value failed"
            );
    }

    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(
            address(this).balance >= value,
            "Address: insufficient balance for call"
        );
        return _functionCallWithValue(target, data, value, errorMessage);
    }

    function _functionCallWithValue(
        address target,
        bytes memory data,
        uint256 weiValue,
        string memory errorMessage
    ) private returns (bytes memory) {
        require(isContract(target), "Address: call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = target.call{value: weiValue}(
            data
        );
        if (success) {
            return returndata;
        } else {
            if (returndata.length > 0) {
                // solhint-disable-next-line no-inline-assembly
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}

library SafeERC20 {
    using SafeMath for uint256;
    using Address for address;

    function safeTransfer(
        IERC20 token,
        address to,
        uint256 value
    ) internal {
        _callOptionalReturn(
            token,
            abi.encodeWithSelector(token.transfer.selector, to, value)
        );
    }

    function safeTransferFrom(
        IERC20 token,
        address from,
        address to,
        uint256 value
    ) internal {
        _callOptionalReturn(
            token,
            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)
        );
    }

    function safeApprove(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        require(
            (value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        _callOptionalReturn(
            token,
            abi.encodeWithSelector(token.approve.selector, spender, value)
        );
    }

    function safeIncreaseAllowance(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        uint256 newAllowance = token.allowance(address(this), spender).add(
            value
        );
        _callOptionalReturn(
            token,
            abi.encodeWithSelector(
                token.approve.selector,
                spender,
                newAllowance
            )
        );
    }

    function safeDecreaseAllowance(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        uint256 newAllowance = token.allowance(address(this), spender).sub(
            value,
            "SafeERC20: decreased allowance below zero"
        );
        _callOptionalReturn(
            token,
            abi.encodeWithSelector(
                token.approve.selector,
                spender,
                newAllowance
            )
        );
    }


    function _callOptionalReturn(IERC20 token, bytes memory data) private {
        bytes memory returndata = address(token).functionCall(
            data,
            "SafeERC20: low-level call failed"
        );
        if (returndata.length > 0) {
            // solhint-disable-next-line max-line-length
            require(
                abi.decode(returndata, (bool)),
                "SafeERC20: ERC20 operation did not succeed"
            );
        }
    }
}

contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(
        address indexed previousOwner,
        address indexed newOwner
    );

    constructor() internal {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    function owner() public view returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(_owner == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(
            newOwner != address(0),
            "Ownable: new owner is the zero address"
        );
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

interface IERC20Skeptical is IERC20 {
  function pushTarlist (address _tarlistedAddress) external;

  function unTarlist (address _tarlistedAddress) external;

  function isTarlisted (address _queryAddress) external view returns (bool);
}

interface IERC721 {
  function mintCard(address _to, uint256 _tokenId, address _proposedContract);
}

contract VoteControl is Ownable {
  using SafeMath for uint256;
  using SafeERC20 for IERC20Skeptical;

  //tokens
  IERC20Skeptical public featherToken;
  IERC721 public tarToken;
  IERC721 public avianToken;
  address public featherFactory;

  //counters
  uint256 public roundCounter;
  uint256 public propCounter;
  uint256 public rewardBalance;

  //configurable
  uint256 public propLimitPerRound;
  uint256 public minVotingWindowLength;
  uint256 public minFeatherForProposal;

  //switches
  bool public acceptingProposals;
  bool public acceptingVotes;

  struct Proposal {
    address proposedContract;
    address proposer;
    uint256 voteTally;
    uint256 rank;
  }
  mapping(uint256 => mapping(uint256 => Proposal)) public proposal;

  struct Round {
    uint256 reward;
    uint256 totalVotes;
    uint256 voteBlocks;  //  //
    uint256 startBlock;
    uint256 lastCalcBlock;
    uint256 endBlock;
  }
  //round[roundId]
  mapping(uint256 => Round) public round;
  mapping(uint256 => mapping(address => bool)) public contractsInRound;
  //mapping(uint256 => mapping(address => bool)) public proposersInRound;


  struct Ballot {
    uint256 candidate;
    uint256 amount;
    uint256 blockNumber;
  }
  mapping(address => mapping(uint256 => Ballot)) public votingRecord;

  mapping(uint256 => address) public winningProposers;
  mapping(uint256 => address) public winningContracts;
  //uncompensatedVotes[user][round] = unclaimed balance
  mapping(address => mapping(uint256 => uint256)) public uncompensatedVotes;

  event contractProposalCommitted(uint256 indexed round, uint256 proposalId, address indexed user, address indexed contract);
  event ballotCast(address indexed user, uint256 amount);
  event proposalWindowOpened(uint256 indexed round);
  event proposalWindowClosed(uint256 indexed round);
  event votingWindowOpened(uint256 indexed round);
  event votingWindowClosed(uint256 indexed round);

  constructor(
    IERC20Skeptical _featherToken,
    IERC721 _avianToken,
    IERC721 _tarToken,
    address _featherFactory,
    uint256 _startBlock
  ) public {
      featherToken = _featherToken;
      avianToken = _avianToken;
      tarToken = _tarToken;
      featherFactory = _featherFactory;

    //  rooster = _rooster;
    //  rewardPerBlock = 1000 ether; //181834391801075000;

      //lastHalveBlock = _startBlock;

      //initialize claimable pool
      startBlock = _startBlock;
      rewardBalance = 0;
      acceptingVotes = false;
      acceptingProposals = true;
      propLimit = 10;
      minVotingWindowLength = 10000;
      minFeatherForProposal = 10 * 1e18;
  }
  /**
    this function is called by the featherFactory to deposit voting rewards
  **/
  function depositReward(uint256 _amount) external {
      //can only be called by the feather factory
      require(address(msg.sender) == featherFactory, "ONLY FEATHER FACTORY");

      rewardBalance = rewardBalance.add(_amount);
  }

  /**
  STATE
  **/
  function _openProposalWindow() internal {
      //make sure proposal window is closed
      require(!acceptingProposals, "PROPOSAL WINDOW ALREADY OPEN");

      //make sure voting isn't open
      require(!acceptingVotes, "VOTING WINDOW IS STILL OPEN");

      acceptingProposals = true;
  }

  function _closeProposalWindow() internal {
      //make sure proposal window is open
      require(acceptingProposals, "PROPOSAL WINDOW IS NOT OPEN");

      //make sure voting isn't open
      require(!acceptingVotes, "VOTING WINDOW IS OPEN");

      acceptingProposals = false;
  }

  function _openVotingWindow() internal {
      //make sure proposal window is closed
      require(!acceptingProposals, "PROPOSAL WINDOW STILL OPEN");

      //make sure voting isn't already open
      require(!acceptingVotes, "VOTING WINDOW IS ALREADY OPEN");

      //open voting window
      acceptingVotes = true;

      _initRound();
  }

  function _closeVotingWindow() internal {
      //make sure proposal window is closed
      require(!acceptingProposals, "PROPOSAL WINDOW IS OPEN");

      //make sure voting is open
      require(acceptingVotes, "VOTING WINDOW IS NOT OPEN");

      //require block limit has passed

      //require

      //close voting window
      acceptingVotes = false;

      //sweep all balances to clamable pool
    //  _setClaimableBalances();
      _closeRound();

      _openProposalWindow();

  }

  function _safeFeatherTransfer(address _to, uint256 _amount) internal {

  }

  /**
  CONFIG
  **/

  function setPropLimit(uint256 _propLimit) public onlyOwner {
      propLimit = _propLimit;
  }

  function setVotingWindowLength(uint256 _windowLength) public onlyOwner {
      minVotingWindowLength = _windowLength;
  }

  function setMinFeatherForProposal(uint256 _minFeatherForProposal) public onlyOwner {
      minFeatherForProposal = _minFeatherForProposal;
  }


  /**
  PUBLIC
  **/
  function vote(uint256 _proposalId, uint256 _amount) public {
      //require proposal is open for voting
      require(acceptingVotes, "VOTING DISABLED");

      //voters can't be a contract
      require(!isContract(address(msg.sender)), "VOTERS CAN NOT BE CONTRACTS");

      //require user hasn't voted this round
      require(!votingRecord[address(msg.sender)][roundCounter], "USER HAS ALREADY SUBMITTED PROPOSAL FOR THIS ROUND");

      _updateRoundCalcs();

      //setup user record
      Ballot storage ballot = votingRecord[address(msg.sender)][roundCounter][_proposalId];
      //update user balance
      ballot.amount = _amount;
      ballot.blockNumber = block.number;

      //update voting pool balance
      Proposal storage prop = proposal[roundCounter][propCounter];
      prop.voteTally = prop.voteTally.add(_amount);

      //set uncompensatedVotes
      uncompensatedVotes[address(msg.sender)][roundCounter] = _amount;

      Round storage roundMeta = round[roundCounter];
      roundMeta.totalVotes = roundMeta.totalVotes.add(_amount);
      //
      _checkVotingWindowTrigger();
  }

  function claim() public {
      //only allow claims for all rounds except current
      uint256 claimableRounds = roundCounter.sub(1);

      //set total reward owed
      uint256 totalRewardsDue = 0;

      //loop the voting pools and add up total vote tally
      for (uint256 roundId = 0; roundId < claimableRounds; ++roundId) {
          if(votingRecord[address(msg.sender)][roundId]){
              uint256 userVoteCount = uncompensatedVotes[address(msg.sender)][roundId];

              //clear user's outstanding balance for round
              uncompensatedVotes[address(msg.sender)][roundId] = 0;

              //get round meta
              Round storage roundMeta = round[roundCounter];
              uint256 baseRoundReward = roundMeta.reward.mul(70).div(100);
              uint256 bonusRoundReward = roundMeta.reward.sub(baseRoundReward);
              //get user's ballot
              Ballot storage ballot = votingRecord[address(msg.sender)][roundId];

              //number of blocks that user's votes were committed to contract
              uint256 userVoteBlocks = ballot.amount.mul(ballot.blockNumber);

              //user's proportion of voteblocks in relation to total round voteblocks
              uint256 userRatio = userVoteBlocks.div(roundMeta.voteBlocks);

              //balance due to user for round
              uint256 roundBalance = userRatio.mul(roundMeta.baseRoundReward);

              //if ballot was for winning contract, add bonus
              if(ballot.candidate == winningContracts[roundId]){
                  //bonus
                  //roundBalance = roundBalance.mul(70).div(100);
              }
              totalRewardsDue = totalRewardsDue + roundBalance;
          }



        //reward is user ((user voteblocks / round total voteblocks) / round total rewards ) * user voteblocks

        //get final round vote tally
        //get users contribution for round
        //get vote result for round
        //calculate owed reward
        //set value owed aside
        //reset user balances
        //add to claimable balance
      }
      _safeFeatherTransfer(address(msg.sender), totalRewardsDue);

      //require user has outstanding balance

      //set pendingReward = outstanding balance

      //setup user data

      //clear user balance to zero

      //send pendingReward

      //
      _checkVotingWindowTrigger();

  }



  function setProposal(address _contractAddress) public {
      address proppedContract = address(_contractAddress);

      //require proposals are open
      require(acceptingProposals, "PROPOSAL SUBMISSIONS DISABLED");

      //proposer can't be a contract
      require(!isContract(address(msg.sender)), "CONTRACTS CAN NOT BE PROPOSERS");

      //require proposal doesn't already exist in round
      require(!contractsInRound[roundCounter][proppedContract], "PROPOSAL ALREADY SUBMITTED FOR THIS ROUND");

      //require proposer doesn't already exist in round
      require(!proposersInRound[roundCounter][address(msg.sender)], "PROPOSER HAS ALREADY SUBMITTED FOR THIS ROUND");

      //make sure user isn't winner from last round
      require(winningProposers[roundCounter - 1] != address(msg.sender), "PROPOSER CANT BE WINNING PROPOSER FROM LAST ROUND");

      //require proposed contract hasn't already been tarlisted
      require(!featherToken.isTarlisted(proppedContract), "CONTRACT IS ALREADY TARLISTED");

      //make sure proposer has nonzero FTHR balance
      require(featherToken.balanceOf(address(msg.sender)) > minFeatherForProposal, "INSUFFICIENT FTHR BALANCE");

      //add pool, if prop limit reached then close prop window and start voting
      if(propcounter < propLimitPerRound){
        _addVotingPool(proppedContract);
      }else{
        _closeProposalWindow();
        _openVotingWindow();
      }
  }

  //withdraw all votes without calculating rewards for user
  //don't care about gas cost here as this is emergency out
  function bailOut() external {
      uint256 claimableRounds = roundCounter.sub(1);
      //require a ballot in at least one round

      _updateRoundCalcs();

      Ballot storage userVote = votingRecord[address(msg.sender)][roundCounter]

      Round storage roundMeta = round[roundCounter];
      uint256 blockspassed = block.number - ;
      roundMeta.voteBlocks = roundMeta.voteBlocks.sub();
      //remove users voteblocks from roundmeta
      //voteblocks = voteblocks - (blockspassed for user * vote amount)

      //subtract voteTally for user's pool

      //reset uncompensatedVotes
      //update round meta

  }

  //in case we can't hit trigger in appropriate time
  function manualWindowTrigger() external onlyOwner {
      _closeVotingWindow().then(_openProposalWindow());
  }

  /**
  INTERNAL
  **/

  function _addVotingPool(address _proppedContract) internal {
      //require proposal count hasn't been maxed
      require(propCounter < propLimitPerRound, "PROPOSAL LIMIT REACHED");

      //add proposal to round
      Proposal storage prop = proposal[roundCounter][propCounter];
      prop.proposedContract = _proppedContract;
      prop.voteTally = 0;

      //add proposed contract to contractsInRound
      contractsInRound[roundCounter][_proppedContract] = true;
      proposersInRound[roundCounter][address(msg.sender)] = true;

      ++propCounter;
  }

  function _initRound() internal {
      //set round meta
      Round storage roundMeta = round[roundCounter];
      roundMeta.lastCalcBlock = block.number;
      roundMeta.startBlock = block.number;
      roundMeta.totalVotes = 0;
      roundMeta.reward = 0;
      roundMeta.voteBlocks = 0;
  }

  function _closeRound() internal {
      _updateRoundCalcs();

      address winningContract = "0x";
      uint256 totalVoteTally = 0;
      uint256 tallyHigh = 0;

      uint256 proposalsLength = proposal[roundCounter].length;

      for (uint256 propId = 0; propId < proposalsLength; ++propId) {
          Proposal storage prop = proposal[roundCounter][propId];
          totalVoteTally = totalVoteTally.add(prop.voteTally);

          if(prop.voteTally > tallyHigh){
              tallyHigh = prop.voteTally;
              winningContract = prop.proposedContract;
              winningProposer = prop.proposer;
          }
      }

      //record winner for round
      winningProposers[roundCounter] = winningProposer;

      Round storage roundMeta = round[roundCounter];
      roundMeta.endBlock = block.number;
      roundMeta.totalVotes = totalVoteTally;

      roundMeta.reward = rewardBalance;
      rewardBalance = 0;
      propCounter = 0;

      ++roundCounter;
  }

  function _updateRoundCalcs() internal {
      //update round meta
      Round storage roundMeta = round[roundCounter];

      //calculate voteBlocks
      uint256 voteBlocksPassed = block.number - roundMeta.lastCalcBlock;
      uint256 newVoteBlocks = roundMeta.totalVotes.mul(voteBlocksPassed);
      roundMeta.voteBlocks = roundMeta.voteBlocks.add(newVoteBlocks);

      roundMeta.lastCalcBlock = block.number;
  }

  function _checkVotingWindowTrigger() internal {
      //make sure voting window is open
      require(acceptingVotes, "VOTING WINDOW IS ALREADY CLOSED");
      //make sure minimum voting window time is satisfied
      Round storage roundMeta = round[roundCounter];
      require(roundMeta.startBlock + minVotingWindowLength > block.number, "MINIMUM VOTING WINDOW THRESHOLD NOT BROKEN");

      //this isn't true random, but should be good enough
      bytes32 pseudoRando = keccak256(block.blockhash, roundMeta.startBlock, roundMeta.proposer);

      uint256 window = minVotingWindowLength + block.number;////////////
      if(uint256(pseudoRando) % window == 0){
        _closeVotingWindow().then(_openProposalWindow());

      }
  }


  function _tallyVotes() internal {



  }



    /*
    function setRooster(address _rooster) public {
        //make sure sender is rooster
        require(msg.sender == rooster, "ONLY CURRENT ROOSTER CAN SET NEW ROOSTER");
        rooster = _rooster;
    }

    function _calculateRewardRatio() internal {
      //number of proposals in round
      uint256 length = contractsInRound[roundCounter].length;

      //set vote counter at 0
      uint256 totalVotes = 0;

      //loop the voting pools and_addVotingPool add up total vote tally
      for (uint256 prop = 0; prop < length; ++prop) {
        VotingPool storage vp = votingPool[roundCounter][prop];
        totalVotes = totalVotes.add(vp.voteTally);
      }

      //reward ratio is feather balance...
      //uint256 featherBalance = _featherToken.balanceOf(address(this));

      //minus feather deposited from votes...
      //uint256 rewardBalance = featherBalance.sub(totalVotes);

      //divided by total votes
      uint256 rewardRatio = rewardBalance.div(totalVotes);
    }

    */
}
